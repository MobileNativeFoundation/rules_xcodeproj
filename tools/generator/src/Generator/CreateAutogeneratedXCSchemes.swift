import OrderedCollections
import PathKit
import XcodeProj

extension Generator {
    /// Creates an array of `XCScheme` entries for the specified targets.
    static func createAutogeneratedXCSchemes(
        schemeAutogenerationMode: SchemeAutogenerationMode,
        buildMode: BuildMode,
        targetHosts: [TargetID: [TargetID]],
        extensionPointIdentifiers: [TargetID: ExtensionPointIdentifier],
        filePathResolver: FilePathResolver,
        consolidatedTargetKeys: [TargetID: ConsolidatedTarget.Key],
        pbxTargets: [ConsolidatedTarget.Key: PBXTarget]
    ) throws -> [XCScheme] {
        guard schemeAutogenerationMode != .none else {
            return []
        }

        var keyedHostPBXTargets: [
            ConsolidatedTarget.Key: OrderedSet<PBXTarget>
        ] = [:]
        for (id, hostIDs) in targetHosts {
            guard let key = consolidatedTargetKeys[id] else {
                throw PreconditionError(message: """
`key` for hosted target target id "\(id)" not found in `consolidatedTargetKeys`.
""")
            }

            for hostID in hostIDs {
                guard let hostKey = consolidatedTargetKeys[hostID] else {
                    throw PreconditionError(message: """
`key` for host target target id "\(id)" not found in `consolidatedTargetKeys`.
""")
                }
                guard let hostPBXTarget = pbxTargets[hostKey] else {
                    throw PreconditionError(message: """
Host target with key \(key) not found in `pbxTargets`.
""")
                }

                keyedHostPBXTargets[key, default: []].append(hostPBXTarget)
            }
        }

        var keyedExtensionPointIdentifiers: [
            ConsolidatedTarget.Key: Set<ExtensionPointIdentifier>
        ] = [:]
        for (id, extensionPointIdentifier) in extensionPointIdentifiers {
            guard let key = consolidatedTargetKeys[id] else {
                throw PreconditionError(message: """
`key` for extension point identifier target id "\(id)" not found in \
`consolidatedTargetKeys`.
""")
            }
            keyedExtensionPointIdentifiers[key, default: []]
                .insert(extensionPointIdentifier)
        }

        let referencedContainer = filePathResolver.containerReference
        return try pbxTargets.compactMap { key, pbxTarget in
            guard pbxTarget.shouldCreateScheme else {
                return nil
            }
            let targetInfo = XCSchemeInfo.TargetInfo(
                pbxTarget: pbxTarget,
                referencedContainer: referencedContainer,
                hostInfos: keyedHostPBXTargets[key, default: []].elements.enumerated()
                .map { hostIndex, hostPBXTarget in
                    .init(
                        pbxTarget: hostPBXTarget,
                        referencedContainer: referencedContainer,
                        index: hostIndex
                    )
                },
                extensionPointIdentifiers: keyedExtensionPointIdentifiers[key, default: []]
            )
            let buildConfigurationName = targetInfo.pbxTarget.defaultBuildConfigurationName

            let shouldCreateTestAction = pbxTarget.isTestable
            let shouldCreateLaunchAction = pbxTarget.isLaunchable
            let schemeInfo = try XCSchemeInfo(
                buildActionInfo: .init(targetInfos: [targetInfo]),
                testActionInfo: shouldCreateTestAction ?
                    .init(
                        buildConfigurationName: buildConfigurationName,
                        targetInfos: [targetInfo]
                    ) : nil,
                launchActionInfo: shouldCreateLaunchAction ?
                    .init(
                        buildConfigurationName: buildConfigurationName,
                        targetInfo: targetInfo
                    ) : nil,
                profileActionInfo: shouldCreateLaunchAction ?
                    .init(
                        buildConfigurationName: buildConfigurationName,
                        targetInfo: targetInfo
                    ) : nil,
                analyzeActionInfo: .init(buildConfigurationName: buildConfigurationName),
                archiveActionInfo: .init(buildConfigurationName: buildConfigurationName)
            ) { buildActionInfo, _, _, _ in
                guard let targetInfo = buildActionInfo?.targetInfos.first else {
                    throw PreconditionError(message: """
Expected to find a `TargetInfo` in the `BuildActionInfo`.
""")
                }
                let schemeName: String
                if let selectedHostInfo = try targetInfo.selectedHostInfo,
                    targetInfo.disambiguateHost
                {
                    schemeName = """
\(targetInfo.pbxTarget.schemeName) in \(selectedHostInfo.pbxTarget.schemeName)
"""
                } else {
                    schemeName = targetInfo.pbxTarget.schemeName
                }
                return schemeName
            }

            return try XCScheme(buildMode: buildMode, schemeInfo: schemeInfo)
        }
    }
}
