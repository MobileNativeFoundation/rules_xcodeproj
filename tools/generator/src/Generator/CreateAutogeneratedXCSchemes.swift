import OrderedCollections
import PathKit
import XcodeProj

extension Generator {
    /// Creates an array of `XCScheme` entries for the specified targets.
    static func createAutogeneratedXCSchemes(
        schemeAutogenerationMode: SchemeAutogenerationMode,
        buildMode: BuildMode,
        targetHosts: [TargetID: [TargetID]],
        extensionPointIdentifiers: [TargetID: ExtensionPointIdentifier],
        filePathResolver: FilePathResolver,
        consolidatedTargetKeys: [TargetID: ConsolidatedTarget.Key],
        pbxTargets: [ConsolidatedTarget.Key: PBXTarget]
    ) throws -> [XCScheme] {
        guard schemeAutogenerationMode != .none else {
            return []
        }

        var keyedHostPBXTargets: [
            ConsolidatedTarget.Key: OrderedSet<PBXTarget>
        ] = [:]
        for (id, hostIDs) in targetHosts {
            guard let key = consolidatedTargetKeys[id] else {
                throw PreconditionError(message: """
`key` for hosted target target id "\(id)" not found in `consolidatedTargetKeys`.
""")
            }

            for hostID in hostIDs {
                guard let hostKey = consolidatedTargetKeys[hostID] else {
                    throw PreconditionError(message: """
`key` for host target target id "\(id)" not found in `consolidatedTargetKeys`.
""")
                }
                guard let hostPBXTarget = pbxTargets[hostKey] else {
                    throw PreconditionError(message: """
Host target with key \(key) not found in `pbxTargets`.
""")
                }

                keyedHostPBXTargets[key, default: []].append(hostPBXTarget)
            }
        }

        var keyedExtensionPointIdentifiers: [
            ConsolidatedTarget.Key: Set<ExtensionPointIdentifier>
        ] = [:]
        for (id, extensionPointIdentifier) in extensionPointIdentifiers {
            guard let key = consolidatedTargetKeys[id] else {
                throw PreconditionError(message: """
`key` for extension point identifier target id "\(id)" not found in \
`consolidatedTargetKeys`.
""")
            }
            keyedExtensionPointIdentifiers[key, default: []]
                .insert(extensionPointIdentifier)
        }

        let referencedContainer = filePathResolver.containerReference
        return try pbxTargets.flatMap { key, pbxTarget in
            try createXCSchemes(
                buildMode: buildMode,
                pbxTargetInfo: .init(pbxTarget: pbxTarget, referencedContainer: referencedContainer),
                hostPBXTargetInfos: keyedHostPBXTargets[key, default: []].elements.map {
                    .init(pbxTarget: $0, referencedContainer: referencedContainer)
                },
                extensionPointIdentifiers:
                    keyedExtensionPointIdentifiers[key, default: []]
            )
        }
    }

    // GH399: Derive the defaultLastUpgradeVersion
    private static let defaultLastUpgradeVersion = "1320"
    private static let lldbInitVersion = "1.7"

    /// Creates an `XCScheme` for the specified target.
    private static func createXCSchemes(
        buildMode: BuildMode,
        pbxTargetInfo: XCScheme.PBXTargetInfo,
        hostPBXTargetInfos: [XCScheme.PBXTargetInfo],
        extensionPointIdentifiers: Set<ExtensionPointIdentifier>
    ) throws -> [XCScheme] {
        guard pbxTargetInfo.pbxTarget.shouldCreateScheme else {
            return []
        }

        guard !hostPBXTargetInfos.isEmpty else {
            return [
                try createXCScheme(
                    buildMode: buildMode,
                    pbxTargetInfo: pbxTargetInfo,
                    hostPBXTargetInfo: nil,
                    hostIndex: nil,
                    disambiguateHost: false,
                    extensionPointIdentifiers: extensionPointIdentifiers
                ),
            ]
        }

        let disambiguateHost = hostPBXTargetInfos.count > 1
        return try hostPBXTargetInfos.enumerated().map { hostIndex, hostPBXTargetInfo in
            try createXCScheme(
                buildMode: buildMode,
                pbxTargetInfo: pbxTargetInfo,
                hostPBXTargetInfo: hostPBXTargetInfo,
                hostIndex: hostIndex,
                disambiguateHost: disambiguateHost,
                extensionPointIdentifiers: extensionPointIdentifiers
            )
        }
    }

    private static func createXCScheme(
        buildMode: BuildMode,
        pbxTargetInfo: XCScheme.PBXTargetInfo,
        hostPBXTargetInfo: XCScheme.PBXTargetInfo?,
        hostIndex: Int?,
        disambiguateHost: Bool,
        extensionPointIdentifiers: Set<ExtensionPointIdentifier>
    ) throws -> XCScheme {
        let isLaunchable = pbxTargetInfo.pbxTarget.isLaunchable
        let isTestable = pbxTargetInfo.pbxTarget.isTestable
        let productType = pbxTargetInfo.pbxTarget.productType ?? .none
        let isWatchApplication = productType.isWatchApplication
        let isWidgetKitExtension = extensionPointIdentifiers
            .contains(.widgetKitExtension)

        let buildConfigurationName = pbxTargetInfo.pbxTarget.defaultBuildConfigurationName
        let runnables = createRunnables(
            buildableReference: pbxTargetInfo.buildableReference,
            isLaunchable: isLaunchable,
            isTestable: isTestable,
            isWidgetKitExtension: isWidgetKitExtension
        )
        let macroExpansions = createMacroExpansions(
            buildableReference: pbxTargetInfo.buildableReference,
            hostBuildableReference: hostPBXTargetInfo?.buildableReference,
            isTestable: isTestable,
            isWatchApplication: isWatchApplication
        )
        let selectedIdentifiers = createSelectedIdentifiers(
            productType: productType
        )
        let launchAutomaticallySubstyle = productType
            .launchAutomaticallySubstyle

        let buildAction = XCScheme.BuildAction(
            buildMode: buildMode,
            targetInfos: [pbxTargetInfo],
            hostBuildableReference: hostPBXTargetInfo?.buildableReference,
            hostIndex: hostIndex
        )
        let launchAction = XCScheme.LaunchAction(
            runnable: runnables.launch,
            buildConfiguration: buildConfigurationName,
            macroExpansion: macroExpansions.launch,
            selectedDebuggerIdentifier: selectedIdentifiers.debugger,
            selectedLauncherIdentifier: selectedIdentifiers.launcher,
            askForAppToLaunch: runnables.askForAppToLaunch,
            environmentVariables: buildMode.usesBazelEnvironmentVariables ?
                productType.bazelLaunchEnvironmentVariables : nil,
            launchAutomaticallySubstyle: launchAutomaticallySubstyle,
            customLLDBInitFile: "$(BAZEL_LLDB_INIT)"
        )
        let testAction = XCScheme.TestAction(
            buildConfiguration: buildConfigurationName,
            macroExpansion: macroExpansions.test,
            testables: createTestables(
                buildableReference: pbxTargetInfo.buildableReference,
                isTestable: isTestable
            ),
            customLLDBInitFile: "$(BAZEL_LLDB_INIT)"
        )
        let profileAction = XCScheme.ProfileAction(
            buildableProductRunnable: runnables.profile,
            buildConfiguration: buildConfigurationName
        )
        let analyzeAction = XCScheme.AnalyzeAction(
            buildConfiguration: buildConfigurationName
        )
        let archiveAction = XCScheme.ArchiveAction(
            buildConfiguration: buildConfigurationName,
            revealArchiveInOrganizer: true
        )

        let schemeName: String
        if let hostPBXTarget = hostPBXTargetInfo?.pbxTarget, disambiguateHost {
            schemeName = """
\(pbxTargetInfo.pbxTarget.schemeName) in \(hostPBXTarget.schemeName)
"""
        } else {
            schemeName = pbxTargetInfo.pbxTarget.schemeName
        }

        return XCScheme(
            name: schemeName,
            lastUpgradeVersion: defaultLastUpgradeVersion,
            version: lldbInitVersion,
            buildAction: buildAction,
            testAction: testAction,
            launchAction: launchAction,
            profileAction: profileAction,
            analyzeAction: analyzeAction,
            archiveAction: archiveAction,
            wasCreatedForAppExtension: productType.isExtension ? true : nil
        )
    }

    private static func createRunnables(
        buildableReference: XCScheme.BuildableReference,
        isLaunchable: Bool,
        isTestable: Bool,
        isWidgetKitExtension: Bool
    ) -> (
        askForAppToLaunch: Bool?,
        launch: XCScheme.Runnable?,
        profile: XCScheme.BuildableProductRunnable?
    ) {
        guard !isTestable else {
            return (askForAppToLaunch: nil, launch: nil, profile: nil)
        }

        let runnable: XCScheme.BuildableProductRunnable? = isLaunchable ?
            .init(buildableReference: buildableReference) : nil

        if isWidgetKitExtension {
            let remoteRunnable = XCScheme.RemoteRunnable(
                buildableReference: buildableReference,
                bundleIdentifier: "com.apple.springboard",
                runnableDebuggingMode: "2"
            )
            return (
                askForAppToLaunch: true,
                launch: remoteRunnable,
                profile: runnable
            )
        } else {
            // If targeting a device for a Watch App, Xcode modifies the scheme
            // to use a `RemoteRunnable`. It does this automatically though, so
            // we don't have to account for it
            return (
                askForAppToLaunch: nil,
                launch: runnable,
                profile: runnable
            )
        }
    }

    private static func createMacroExpansions(
        buildableReference: XCScheme.BuildableReference,
        hostBuildableReference: XCScheme.BuildableReference?,
        isTestable: Bool,
        isWatchApplication: Bool
    ) -> (
        launch: XCScheme.BuildableReference?,
        test: XCScheme.BuildableReference?
    ) {
        if let hostBuildableReference = hostBuildableReference,
           !isWatchApplication
        {
            return (launch: hostBuildableReference, test: nil)
        } else if isTestable {
            return (launch: buildableReference, test: nil)
        } else {
            return (launch: nil, test: nil)
        }
    }

    private static func createSelectedIdentifiers(
        productType: PBXProductType
    ) -> (launcher: String, debugger: String) {
        if productType.canUseDebugLauncher {
            return (
                launcher: XCScheme.defaultLauncher,
                debugger: XCScheme.defaultDebugger
            )
        } else {
            return (
                launcher: "Xcode.IDEFoundation.Launcher.PosixSpawn",
                debugger: ""
            )
        }
    }

    private static func createTestables(
        buildableReference: XCScheme.BuildableReference,
        isTestable: Bool
    ) -> [XCScheme.TestableReference] {
        guard isTestable else {
            return []
        }

        return [.init(
            skipped: false,
            buildableReference: buildableReference
        )]
    }
}
