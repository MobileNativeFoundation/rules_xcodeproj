import OrderedCollections
import PathKit
import XcodeProj

extension Generator {
    /// Creates an array of `XCScheme` entries for the specified targets.
    static func createAutogeneratedXCSchemes(
        schemeAutogenerationMode: SchemeAutogenerationMode,
        buildMode: BuildMode,
        targetHosts: [TargetID: [TargetID]],
        extensionPointIdentifiers: [TargetID: ExtensionPointIdentifier],
        filePathResolver: FilePathResolver,
        consolidatedTargetKeys: [TargetID: ConsolidatedTarget.Key],
        pbxTargets: [ConsolidatedTarget.Key: PBXTarget]
    ) throws -> [XCScheme] {
        guard schemeAutogenerationMode != .none else {
            return []
        }

        var keyedHostPBXTargets: [
            ConsolidatedTarget.Key: OrderedSet<PBXTarget>
        ] = [:]
        for (id, hostIDs) in targetHosts {
            guard let key = consolidatedTargetKeys[id] else {
                throw PreconditionError(message: """
`key` for hosted target target id "\(id)" not found in `consolidatedTargetKeys`.
""")
            }

            for hostID in hostIDs {
                guard let hostKey = consolidatedTargetKeys[hostID] else {
                    throw PreconditionError(message: """
`key` for host target target id "\(id)" not found in `consolidatedTargetKeys`.
""")
                }
                guard let hostPBXTarget = pbxTargets[hostKey] else {
                    throw PreconditionError(message: """
Host target with key \(key) not found in `pbxTargets`.
""")
                }

                keyedHostPBXTargets[key, default: []].append(hostPBXTarget)
            }
        }

        var keyedExtensionPointIdentifiers: [
            ConsolidatedTarget.Key: Set<ExtensionPointIdentifier>
        ] = [:]
        for (id, extensionPointIdentifier) in extensionPointIdentifiers {
            guard let key = consolidatedTargetKeys[id] else {
                throw PreconditionError(message: """
`key` for extension point identifier target id "\(id)" not found in \
`consolidatedTargetKeys`.
""")
            }
            keyedExtensionPointIdentifiers[key, default: []]
                .insert(extensionPointIdentifier)
        }

        let referencedContainer = filePathResolver.containerReference
        return try pbxTargets.map { key, pbxTarget in
            let targetInfo = XCSchemeInfo.TargetInfo(
                pbxTarget: pbxTarget,
                referencedContainer: referencedContainer,
                hostInfos: keyedHostPBXTargets[key, default: []].elements.enumerated()
                .map { hostIndex, hostPBXTarget in
                    .init(
                        pbxTarget: hostPBXTarget,
                        referencedContainer: referencedContainer,
                        index: hostIndex
                    )
                },
                extensionPointIdentifiers: keyedExtensionPointIdentifiers[key, default: []]
            )
            let buildConfigurationName = targetInfo.pbxTarget.defaultBuildConfigurationName

            let schemeInfo = try XCSchemeInfo(
                // TODO(chuck): Implement the host selection.
                // TODO(chuck): Implement the original schemeName logic
                name: pbxTarget.schemeName,
                buildActionInfo: .init(targetInfos: [targetInfo]),
                testActionInfo: targetInfo.pbxTarget.isTestable ?
                    .init(
                        buildConfigurationName: buildConfigurationName,
                        targetInfos: [targetInfo]
                    ) : nil,
                launchActionInfo: targetInfo.pbxTarget.isLaunchable ?
                    .init(
                        buildConfigurationName: buildConfigurationName,
                        targetInfo: targetInfo
                    ) : nil,
                profileActionInfo: targetInfo.pbxTarget.isLaunchable ?
                    .init(
                        buildConfigurationName: buildConfigurationName,
                        targetInfo: targetInfo
                    ) : nil,
                analyzeActionInfo: .init(buildConfigurationName: buildConfigurationName),
                archiveActionInfo: .init(buildConfigurationName: buildConfigurationName)
            )

            return XCScheme(buildMode: buildMode, schemeInfo: schemeInfo)
        }
    }

    // /// Creates an array of `XCScheme` entries for the specified targets.
    // static func createAutogeneratedXCSchemes(
    //     schemeAutogenerationMode: SchemeAutogenerationMode,
    //     buildMode: BuildMode,
    //     targetHosts: [TargetID: [TargetID]],
    //     extensionPointIdentifiers: [TargetID: ExtensionPointIdentifier],
    //     filePathResolver: FilePathResolver,
    //     consolidatedTargetKeys: [TargetID: ConsolidatedTarget.Key],
    //     pbxTargets: [ConsolidatedTarget.Key: PBXTarget]
    // ) throws -> [XCScheme] {
    //     guard schemeAutogenerationMode != .none else {
    //         return []
    //     }

    //     var keyedHostPBXTargets: [
    //         ConsolidatedTarget.Key: OrderedSet<PBXTarget>
    //     ] = [:]
    //     for (id, hostIDs) in targetHosts {
    //         guard let key = consolidatedTargetKeys[id] else {
    //             throw PreconditionError(message: """
// `key` for hosted target target id "\(id)" not found in `consolidatedTargetKeys`.
// """)
    //         }

    //         for hostID in hostIDs {
    //             guard let hostKey = consolidatedTargetKeys[hostID] else {
    //                 throw PreconditionError(message: """
// `key` for host target target id "\(id)" not found in `consolidatedTargetKeys`.
// """)
    //             }
    //             guard let hostPBXTarget = pbxTargets[hostKey] else {
    //                 throw PreconditionError(message: """
// Host target with key \(key) not found in `pbxTargets`.
// """)
    //             }

    //             keyedHostPBXTargets[key, default: []].append(hostPBXTarget)
    //         }
    //     }

    //     var keyedExtensionPointIdentifiers: [
    //         ConsolidatedTarget.Key: Set<ExtensionPointIdentifier>
    //     ] = [:]
    //     for (id, extensionPointIdentifier) in extensionPointIdentifiers {
    //         guard let key = consolidatedTargetKeys[id] else {
    //             throw PreconditionError(message: """
// `key` for extension point identifier target id "\(id)" not found in \
// `consolidatedTargetKeys`.
// """)
    //         }
    //         keyedExtensionPointIdentifiers[key, default: []]
    //             .insert(extensionPointIdentifier)
    //     }

    //     let referencedContainer = filePathResolver.containerReference
    //     return try pbxTargets.flatMap { key, pbxTarget in
    //         try createXCSchemes(
    //             buildMode: buildMode,
    //             targetInfo: .init(
    //                 pbxTarget: pbxTarget,
    //                 referencedContainer: referencedContainer,
    //                 hostInfos: keyedHostPBXTargets[key, default: []].elements.enumerated()
    //                     .map { hostIndex, hostPBXTarget in
    //                         .init(
    //                             pbxTarget: hostPBXTarget,
    //                             referencedContainer: referencedContainer,
    //                             index: hostIndex
    //                         )
    //                     },
    //                 extensionPointIdentifiers:
    //                     keyedExtensionPointIdentifiers[key, default: []]
    //             )
    //         )
    //     }
    // }

    // // GH399: Derive the defaultLastUpgradeVersion
    // private static let defaultLastUpgradeVersion = "1320"
    // private static let lldbInitVersion = "1.7"

    // /// Creates an `XCScheme` for the specified target.
    // private static func createXCSchemes(
    //     buildMode: BuildMode,
    //     targetInfo: XCSchemeInfo.TargetInfo
    // ) throws -> [XCScheme] {
    //     guard targetInfo.pbxTarget.shouldCreateScheme else {
    //         return []
    //     }

    //     guard !targetInfo.hostInfos.isEmpty else {
    //         return [
    //             try createXCScheme(
    //                 buildMode: buildMode,
    //                 targetInfo: targetInfo,
    //                 hostInfo: nil,
    //                 disambiguateHost: targetInfo.disambiguateHost
    //             ),
    //         ]
    //     }

    //     return try targetInfo.hostInfos.map { hostInfo in
    //         try createXCScheme(
    //             buildMode: buildMode,
    //             targetInfo: targetInfo,
    //             hostInfo: hostInfo,
    //             disambiguateHost: targetInfo.disambiguateHost
    //         )
    //     }
    // }

    // private static func createXCScheme(
    //     buildMode: BuildMode,
    //     targetInfo: XCSchemeInfo.TargetInfo,
    //     hostInfo: XCSchemeInfo.HostInfo?,
    //     disambiguateHost: Bool
    // ) throws -> XCScheme {
    //     let isLaunchable = targetInfo.pbxTarget.isLaunchable
    //     let isTestable = targetInfo.pbxTarget.isTestable
    //     let productType = targetInfo.pbxTarget.productType ?? .none
    //     let isWatchApplication = productType.isWatchApplication
    //     let isWidgetKitExtension = targetInfo.extensionPointIdentifiers
    //         .contains(.widgetKitExtension)

    //     let buildConfigurationName = targetInfo.pbxTarget.defaultBuildConfigurationName
    //     let runnables = createRunnables(
    //         buildableReference: targetInfo.buildableReference,
    //         isLaunchable: isLaunchable,
    //         isTestable: isTestable,
    //         isWidgetKitExtension: isWidgetKitExtension
    //     )
    //     let macroExpansions = createMacroExpansions(
    //         buildableReference: targetInfo.buildableReference,
    //         hostBuildableReference: hostInfo?.buildableReference,
    //         isTestable: isTestable,
    //         isWatchApplication: isWatchApplication
    //     )
    //     let selectedIdentifiers = createSelectedIdentifiers(
    //         productType: productType
    //     )
    //     let launchAutomaticallySubstyle = productType
    //         .launchAutomaticallySubstyle

    //     let buildAction = XCScheme.BuildAction(
    //         buildMode: buildMode,
    //         targetInfos: [targetInfo]
    //         // hostBuildableReference: hostInfo?.buildableReference,
    //         // hostIndex: hostInfo?.index
    //     )
    //     let launchAction = XCScheme.LaunchAction(
    //         runnable: runnables.launch,
    //         buildConfiguration: buildConfigurationName,
    //         macroExpansion: macroExpansions.launch,
    //         selectedDebuggerIdentifier: selectedIdentifiers.debugger,
    //         selectedLauncherIdentifier: selectedIdentifiers.launcher,
    //         askForAppToLaunch: runnables.askForAppToLaunch,
    //         environmentVariables: buildMode.usesBazelEnvironmentVariables ?
    //             productType.bazelLaunchEnvironmentVariables : nil,
    //         launchAutomaticallySubstyle: launchAutomaticallySubstyle,
    //         customLLDBInitFile: "$(BAZEL_LLDB_INIT)"
    //     )
    //     let testAction = XCScheme.TestAction(
    //         buildConfiguration: buildConfigurationName,
    //         macroExpansion: macroExpansions.test,
    //         testables: createTestables(
    //             buildableReference: targetInfo.buildableReference,
    //             isTestable: isTestable
    //         ),
    //         customLLDBInitFile: "$(BAZEL_LLDB_INIT)"
    //     )
    //     let profileAction = XCScheme.ProfileAction(
    //         buildableProductRunnable: runnables.profile,
    //         buildConfiguration: buildConfigurationName
    //     )
    //     let analyzeAction = XCScheme.AnalyzeAction(
    //         buildConfiguration: buildConfigurationName
    //     )
    //     let archiveAction = XCScheme.ArchiveAction(
    //         buildConfiguration: buildConfigurationName,
    //         revealArchiveInOrganizer: true
    //     )

    //     let schemeName: String
    //     if let hostPBXTarget = hostInfo?.pbxTarget, disambiguateHost {
    //         schemeName = """
// \(targetInfo.pbxTarget.schemeName) in \(hostPBXTarget.schemeName)
// """
    //     } else {
    //         schemeName = targetInfo.pbxTarget.schemeName
    //     }

    //     return XCScheme(
    //         name: schemeName,
    //         lastUpgradeVersion: defaultLastUpgradeVersion,
    //         version: lldbInitVersion,
    //         buildAction: buildAction,
    //         testAction: testAction,
    //         launchAction: launchAction,
    //         profileAction: profileAction,
    //         analyzeAction: analyzeAction,
    //         archiveAction: archiveAction,
    //         wasCreatedForAppExtension: productType.isExtension ? true : nil
    //     )
    // }

    // private static func createRunnables(
    //     buildableReference: XCScheme.BuildableReference,
    //     isLaunchable: Bool,
    //     isTestable: Bool,
    //     isWidgetKitExtension: Bool
    // ) -> (
    //     askForAppToLaunch: Bool?,
    //     launch: XCScheme.Runnable?,
    //     profile: XCScheme.BuildableProductRunnable?
    // ) {
    //     guard !isTestable else {
    //         return (askForAppToLaunch: nil, launch: nil, profile: nil)
    //     }

    //     let runnable: XCScheme.BuildableProductRunnable? = isLaunchable ?
    //         .init(buildableReference: buildableReference) : nil

    //     if isWidgetKitExtension {
    //         let remoteRunnable = XCScheme.RemoteRunnable(
    //             buildableReference: buildableReference,
    //             bundleIdentifier: "com.apple.springboard",
    //             runnableDebuggingMode: "2"
    //         )
    //         return (
    //             askForAppToLaunch: true,
    //             launch: remoteRunnable,
    //             profile: runnable
    //         )
    //     } else {
    //         // If targeting a device for a Watch App, Xcode modifies the scheme
    //         // to use a `RemoteRunnable`. It does this automatically though, so
    //         // we don't have to account for it
    //         return (
    //             askForAppToLaunch: nil,
    //             launch: runnable,
    //             profile: runnable
    //         )
    //     }
    // }

    // private static func createMacroExpansions(
    //     buildableReference: XCScheme.BuildableReference,
    //     hostBuildableReference: XCScheme.BuildableReference?,
    //     isTestable: Bool,
    //     isWatchApplication: Bool
    // ) -> (
    //     launch: XCScheme.BuildableReference?,
    //     test: XCScheme.BuildableReference?
    // ) {
    //     if let hostBuildableReference = hostBuildableReference,
    //        !isWatchApplication
    //     {
    //         return (launch: hostBuildableReference, test: nil)
    //     } else if isTestable {
    //         return (launch: buildableReference, test: nil)
    //     } else {
    //         return (launch: nil, test: nil)
    //     }
    // }

    // private static func createSelectedIdentifiers(
    //     productType: PBXProductType
    // ) -> (launcher: String, debugger: String) {
    //     if productType.canUseDebugLauncher {
    //         return (
    //             launcher: XCScheme.defaultLauncher,
    //             debugger: XCScheme.defaultDebugger
    //         )
    //     } else {
    //         return (
    //             launcher: "Xcode.IDEFoundation.Launcher.PosixSpawn",
    //             debugger: ""
    //         )
    //     }
    // }

    // private static func createTestables(
    //     buildableReference: XCScheme.BuildableReference,
    //     isTestable: Bool
    // ) -> [XCScheme.TestableReference] {
    //     guard isTestable else {
    //         return []
    //     }

    //     return [.init(
    //         skipped: false,
    //         buildableReference: buildableReference
    //     )]
    // }
}
