# Custom Xcode Schemes

This document is a proposal for how custom Xcode schemes can be defined and implemented in
`rules_xcodeproj`.

## No Custom Schemes

As of this writing, the ruleset generates an Xcode scheme for every buildable target provided to
the `xcodeproj` rule. This allows a client to quickly define an `xcodeproj` target and generate an
Xcode project.

The following declaration will generate two schemes: `Foo` and
`FooTests.__internal__.__test_bundle`. The `Foo` scheme contains configuration that builds
`//Sources/Foo`, but has no configuration for test, launch or any of the other actions. The
`FooTests.__internal__.__test_bundle` scheme contains configuration that builds `//Tests/FooTests`
and executes the test.

```python
# Assumptions
#   //Sources/Foo:Foo - swift_library
#   //Sources/FooTests:FooTests = ios_unit_test

xcodeproj(
    name = "generate_xcodeproj",
    project_name = "Command Line",
    tags = ["manual"],
    targets = [
        "//Sources/Foo",
        "//Tests/FooTests",
    ],
)
```

While functional, most developers would prefer a single scheme that built both targets and executed
the `//Test/FooTests` target when test execution was requested.

## Introduction of the `scheme` Rule

The `scheme` rule allows a client to define an Xcode scheme. It provides an `XcodeSchemeInfo`
provider which contains information about the scheme. It does not generate any files during the
build. (The current scheme generation logic requires information that is not available outside of
the `xcodeproj` generation logic.)

### New Providers

```python
XcodeSchemeInfo = provider(
    "Provides information about an Xcode scheme.",
    fields = {
        "scheme_name": """\
The user-visible name for the scheme.\
""",
        "build_action": """\
An `XcodeBuildActionInfo` that contains the targets to be built along with any \
build information.\
""",
        "test_action": """\
Optional. An `XcodeTestActionInfo` that lists the testable targets.\
""",
        "launch_action": """\
Optional. An `XcodeLaunchActionInfo` that identifies the target to execute on \
launch along with any arguments and environment variables.\
""",
    },
)

XcodeBuildActionInfo = provider(
    "Provides information about an Xcode build action.",
    fields = {
        "targets": """\
A `depset` of targets to build.\
""",
    },
)

XcodeTestActionInfo = provider(
    "Provides information about an Xcode test action.",
    fields = {
        "targets": """\
A `depset` of targets to execute when testing is requested.\
""",
    },
)

XcodeLaunchActionInfo = provider(
    "Provides information about an Xcode launch action.",
    fields = {
        "target": """\
A `struct` describing the target to launch with the run action is requested.\
""",
        "args": """\
A `list` of `string` values that are passed as arguments when the launch target \
is executed.\
"""'
    },
        "env": """\
A `dict` of enviornment variables to set when the launch target is executed.\
"""'
    },
)
```

### Updates to `xcodeproj`

The `xcodeproj` rule, in addition to the existing target types, now accepts targets that provide
`XcodeSchemeInfo`. The targets contained in `XcodeSchemeInfo` instances are included in the set of
targets that are used to generate the Xcode project. Any targets that are provided by other means
(i.e., not through `XcodeSchemeInfo`) will have an `XcodeSchemeInfo` instance created for it. This
ensures that the current autogenerated scheme behavior is preserved.

### Simple Example Using `scheme`

Building on the previous example, let's define a scheme that combines the two targets.

```python
scheme(
    name = "foo_scheme",
    scheme_name = "Foo Module",
    targets = [
        "//Sources/Foo",
        "//Tests/FooTests",
    ],
)

xcodeproj(
    name = "generate_xcodeproj",
    project_name = "Command Line",
    tags = ["manual"],
    targets = [
        ":foo_scheme",
    ],
)
```

The `foo_scheme` target generates a scheme with a user visible name of `Foo Module`. It is
configured to build `//Sources/Foo` and `//Tests/FooTests`. It is also configured to execute the
test `//Tests/FooTests` using the existing logic for identifying testable targets. A launch action
is not defined.

## Launch Actions

### Automatic Detection of the Launch Target

Let's continue our example. We will add an `ios_application` and a `ios_ui_test` to the mix.

```python
# Assumptions
#   //Sources/Foo:Foo - swift_library
#   //Sources/FooTests:FooTests = ios_unit_test
#   //Sources/App = ios_application
#   //Sources/AppUITests = ios_ui_test

scheme(
    name = "foo_scheme",
    scheme_name = "Foo Module",
    targets = [
        "//Sources/Foo",
        "//Tests/FooTests",
    ],
)

scheme(
    name = "app_scheme",
    scheme_name = "My Application",
    targets = [
        "//Sources/App",
        "//Sources/Foo",
        "//Tests/AppUITests",
        "//Tests/FooTests",
    ],
)

xcodeproj(
    name = "generate_xcodeproj",
    project_name = "Command Line",
    tags = ["manual"],
    schemes = [
        ":app_scheme",
        ":foo_scheme",
    ],
)
```

In the above example, we have added a new scheme called `app_scheme`. It includes the
`ios_application` and `ios_ui_test` targets in addition to the previously defined targets. This
scheme will build `//Sources/App`, `//Sources/Foo`, `//Tests/AppUITests`, and `//Tests/FooTests`.
When tests are requested, the `//Tests/AppUITests` and `//Tests/FooTests` will be executed. When a
launch is requested, the `//Sources/App` will be executed. 

The existing launchable target detection logic will be used to identify the launch target. If more
than one launch target is specified, the first one encountered will be selected as the launch
target. 

The `xcodeproj` logic will combine the targets from both schemes to create the final set of targets
to be included in the Xcode project.


### Specify the Launch Target (`launch_action` Rule)

While the automatic detection of the launch target may work for many cases, it may be desirable to
specify the launch target. This will be done using the `launch_action` rule. This rule provides an
`XcodeLaunchActionInfo` provider.

The following expands the previous example by adding a `launch_action` rule to identify the launch
target.

```python
# Assumptions
#   //Sources/Foo:Foo - swift_library
#   //Sources/FooTests:FooTests = ios_unit_test
#   //Sources/App = ios_application
#   //Sources/AppUITests = ios_ui_test

scheme(
    name = "foo_scheme",
    scheme_name = "Foo Module",
    targets = [
        "//Sources/Foo",
        "//Tests/FooTests",
    ],
)

launch_action(
    name = "app_launch_action",
    target = "//Sources/App",
)

scheme(
    name = "app_scheme",
    scheme_name = "My Application",
    targets = [
        ":app_launch_action",
        "//Sources/Foo",
        "//Tests/AppUITests",
        "//Tests/FooTests",
    ],
)

xcodeproj(
    name = "generate_xcodeproj",
    project_name = "Command Line",
    tags = ["manual"],
    schemes = [
        ":app_scheme",
        ":foo_scheme",
    ],
)
```

In the above example, we added a `launch_action` called `app_launch_action`. We then replaced the
reference to `//Sources/App` in the `app_scheme` targets list to `:app_launch_action`. The target
from the `launch_action` is added to the buildable targets for the `app_scheme` scheme.

### Specify Launch Arguments and Environment Variables

A client may want to provide arguments to the executable or set environment variables in the
executable's launch environment. This is achieved by specifying those items on the `launch_action`
declaration.

Let's configure the launch action to provide some arguments and an environment variable.

```python
# Assumptions
#   //Sources/Foo:Foo - swift_library
#   //Sources/FooTests:FooTests = ios_unit_test
#   //Sources/App = ios_application
#   //Sources/AppUITests = ios_ui_test

scheme(
    name = "foo_scheme",
    scheme_name = "Foo Module",
    targets = [
        "//Sources/Foo",
        "//Tests/FooTests",
    ],
)

launch_action(
    name = "app_launch_action",
    target = "//Sources/App",
    args = [
        "--my_awesome_flag",
        "path/to/a/file.txt",
    ],
    env = {
        "RELEASE_THE_KRAKEN": "true",
    },
)

scheme(
    name = "app_scheme",
    scheme_name = "My Application",
    targets = [
        ":app_launch_action",
        "//Sources/Foo",
        "//Tests/AppUITests",
        "//Tests/FooTests",
    ],
)

xcodeproj(
    name = "generate_xcodeproj",
    project_name = "Command Line",
    tags = ["manual"],
    schemes = [
        ":app_scheme",
        ":foo_scheme",
    ],
)
```

The only change from the previous example is the addition of the `args` and `env` to the
`app_launch_action` declaration. Now, requesting a run action will execute `//Sources/App` with the
specified arguments with the specified environment variables.

---

## SCRATCH

```python
# Assumptions
#   //Sources/Foo:Foo - swift_library
#   //Sources/FooTests:FooTests = ios_unit_test
#   //Sources/App = ios_application
#   //Sources/AppUITests = ios_ui_test

scheme(
    name = "foo_scheme",
    scheme_name = "Foo Module",
    targets = [
        "//Sources/Foo",
        "//Tests/FooTests",
    ],
)

scheme(
    name = "bar_scheme",
    scheme_name = "Bar Module",
    targets = [
        "//Sources/Bar",
        "//Tests/BarTests",
    ],
)

launch_action(
    name = "app_launch_action",
    target = "//Sources/App,"
    args = [
        "path/to/a/file.txt",
    ]
    env = {
        "RELEASE_THE_KRAKEN": "true",
    }
)

scheme(
    name = "app_scheme",
    scheme_name = "My Application",
    targets = [
        ":app_launch_action",
        "//Sources/Foo",
        "//Sources/Bar",
        "//Tests/FooTests",
        "//Tests/BarTests",
        "//Tests/AppUITests",
    ],
)

xcodeproj(
    name = "generate_xcodeproj",
    project_name = "Command Line",
    tags = ["manual"],
    schemes = [
        ":foo_app_scheme",
        ":foo_scheme",
        ":bar_scheme",
    ],
)
```
